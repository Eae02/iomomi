#ifndef GB_COMMON_H
#define GB_COMMON_H

#include "../Inc/Utils.glh"

const vec3 COLOR = vec3(0.1, 0.7, 0.9);
const vec3 COLOR_RED = vec3(1.0, 0.2, 0.3) * 2;

const int OFF_SAMPLES = 4;
const int DUP_LINES = 6;
const float OFFSET_SCALE = 0.8;
const float OFFSET_SCALE_RED = 1.5;
const float LINE_SPACING = 0.5;
const float LINE_WIDTH = 0.003;
const float MAX_INTENSITY = 0.9;
const float EDGE_FADE_DIST = 0.2;
const float TIME_AXIS_SCALE = 0.25;

layout(push_constant) uniform PC
{
	vec3 position;
	float opacity;
	vec4 tangent;
	vec4 bitangent;
	uint blockedAxis;
} pc;

float lineIntensity(float lx, float tx)
{
	float dist = tx - lx * LINE_SPACING;
	if (abs(dist) < 0.01 && length(vec2(dFdx(dist), dFdy(dist))) > abs(dist * 2.0))
		dist = 0;
	float ldist = (max(abs(dist), LINE_WIDTH) - LINE_WIDTH * MAX_INTENSITY);
	return 1.0 / ldist;
}

layout(binding=1) uniform sampler2D noiseTex;

float calcEdgeDist(vec2 scaledTC)
{
	float halfSize = pc.bitangent.w * 0.5;
	return min((halfSize - abs(scaledTC.y - halfSize)) * TIME_AXIS_SCALE / EDGE_FADE_DIST, 1.0);
}

#ifdef GB_WITH_BARRIER_SETTINGS_UB
const int NUM_INTERACTABLES = 8;
layout(binding=2, std140) uniform BarrierSettingsUB
{
	uvec4 iaDownAxis[NUM_INTERACTABLES / 4];
	vec4 iaPosition[NUM_INTERACTABLES];
	float barrierAnimTime;
};
float getInteractablesNegScale(vec3 worldPos, inout vec2 scaledTC, float waterDist)
{
	float negScale = 1.0 - smoothstep(0.5, 0.8, waterDist);
	float stretch = 0;
	for (int i = 0; i < NUM_INTERACTABLES; i++)
	{
		vec3 toObject = worldPos - iaPosition[i].xyz;
		float d = length(toObject);
		uint da = iaDownAxis[i / 4][i % 4];
		
		if (da == pc.blockedAxis)
		{
			negScale += 1.0 - smoothstep(1.0, 1.5, d);
		}
		else if (da != 3)
		{
			float ns = exp(-d * d) * dot(toObject, pc.tangent.xyz) * pc.tangent.w;
			stretch = abs(ns) > abs(stretch) ? ns : stretch;
		}
	}
	
	float edgeDist = calcEdgeDist(scaledTC);
	scaledTC.x -= 0.3 * stretch * edgeDist;
	return clamp(negScale, 0.0, 1.0);
}
#else
const float barrierAnimTime = 0;
#endif

vec4 calculateColor(vec2 scaledTC, float negScale, float baseIntensity)
{
	float intensity = baseIntensity;
	
	float edgeDist = calcEdgeDist(scaledTC);
	float centerLn = floor(scaledTC.x / LINE_SPACING);
	float offScale = edgeDist * mix(OFFSET_SCALE, OFFSET_SCALE_RED, negScale) / DUP_LINES;
	
	for (int d = 0; d < DUP_LINES; d++)
	{
		float off = -0.5 * OFF_SAMPLES;
		for (int j = 0; j < OFF_SAMPLES; j++)
		{
			float sx = ((centerLn * DUP_LINES + d) * OFF_SAMPLES + j) * 0.01;
			float sy = scaledTC.y * TIME_AXIS_SCALE + barrierAnimTime * (j / float(OFF_SAMPLES - 1));
			off += texture(noiseTex, vec2(sx, sy)).r;
		}
		intensity += lineIntensity(centerLn + 0.5 + off * offScale, scaledTC.x);
	}
	
	intensity += lineIntensity(centerLn - 0.5, scaledTC.x) * DUP_LINES;
	intensity += lineIntensity(centerLn + 1.5, scaledTC.x) * DUP_LINES;
	intensity *= pc.opacity;
	
	return vec4(mix(COLOR, COLOR_RED, negScale) * intensity, min(intensity, 1.0));
}

#endif
