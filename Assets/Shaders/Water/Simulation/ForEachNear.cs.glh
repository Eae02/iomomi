#ifdef VNoSubgroups

#define SUBGROUP_UNIFORM(V) V

shared NEAR_PAIR_RES_T sharedClusteredAdd[64];

NEAR_PAIR_RES_T clusteredAdd8(NEAR_PAIR_RES_T value)
{
	sharedClusteredAdd[gl_LocalInvocationID.x] = value;
	for (uint i = 1; i <= 4; i <<= 1)
	{
		memoryBarrierShared();
		barrier();
		if ((gl_LocalInvocationID.x & i) == 0)
		{
			sharedClusteredAdd[gl_LocalInvocationID.x] += sharedClusteredAdd[gl_LocalInvocationID.x | i];
		}
	}
	// only the first invocation will return the correct value but that is ok
	return sharedClusteredAdd[gl_LocalInvocationID.x];
}

#else // VNoSubgroups

#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define SUBGROUP_UNIFORM(V) subgroupBroadcastFirst(V)

#ifdef VSubgroupsNoClustered

#extension GL_KHR_shader_subgroup_shuffle : enable
NEAR_PAIR_RES_T clusteredAdd8(NEAR_PAIR_RES_T value)
{
	value += subgroupShuffleXor(value, 1);
	value += subgroupShuffleXor(value, 2);
	value += subgroupShuffleXor(value, 4);
	return value;
}

#else // VSubgroupsNoClustered

#extension GL_KHR_shader_subgroup_clustered : enable
NEAR_PAIR_RES_T clusteredAdd8(NEAR_PAIR_RES_T value)
{
	return subgroupClusteredAdd(value, 8);
}
#endif // VSubgroupsNoClustered

#endif // VNoSubgroups

#include "../WaterCommon.glh"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void initialize(uint particleIndex, vec3 pos);
NEAR_PAIR_RES_T processNearPair(uint i1, uint i2, vec3 pos1, vec3 pos2);
void processResult(NEAR_PAIR_RES_T result, uint particleIndex);

layout(set = 0, binding = 0) restrict readonly buffer OctGroupsRangesBuffer
{
	uint octGroupRanges[];
};

layout(set = 0, binding = 1) restrict buffer ParticleDataBuffer
{
	uvec4 particleData[];
};

layout(set = 0, binding = 2, r16ui) restrict readonly uniform uimage3D cellOffsetsImage;

uint readCellOffset(ivec3 cellPos)
{
	if (all(greaterThanEqual(cellPos, ivec3(0))) && all(lessThan(cellPos, imageSize(cellOffsetsImage))))
		return imageLoad(cellOffsetsImage, cellPos).r;
	else
		return CELL_OFFSETS_CELL_EMPTY;
}

void main()
{
#ifdef VNoSubgroups
	uint localIndex = gl_LocalInvocationID.x;
#else
	uint localIndex = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;
#endif

	uint centerOctGroupParticleIdx = localIndex / 8;
	uint neighborOctGroupParticleIdx = localIndex % 8;

	uint octGroupOffset = octGroupRanges[gl_WorkGroupID.x];
	uvec4 position0 = particleData[positionsBufferOffset + octGroupOffset];
	uint cellID0 = position0.w;
	ivec3 gridCell = ivec3(getGridCell(uintBitsToFloat(position0.xyz), gridOrigin));

	uint centerParticleIdx = octGroupOffset + centerOctGroupParticleIdx;

	uvec4 positionData = particleData[positionsBufferOffset + centerParticleIdx];
	uint cellID = positionData.w;
	vec3 position = uintBitsToFloat(positionData.xyz);

#ifndef VNoSubgroups
	if (subgroupAll(cellID != cellID0))
		return;
#endif

	initialize(centerParticleIdx, position.xyz);

	NEAR_PAIR_RES_T accumulatedValue = NEAR_PAIR_RES_T(0.0);

	for (int dz = -1; dz <= 1; dz++)
	{
		for (int dy = -1; dy <= 1; dy++)
		{
			for (int dx = -1; dx <= 1; dx++)
			{
				uint neiBeginOffset = readCellOffset(gridCell + ivec3(dx, dy, dz));
				if (SUBGROUP_UNIFORM(neiBeginOffset == CELL_OFFSETS_CELL_EMPTY))
					continue;
				uint neiExpectedCellID = particleData[positionsBufferOffset + neiBeginOffset].w;

				for (uint i = 0; i < W_MAX_OCT_GROUPS_PER_CELL; i++)
				{
					uint neiParticleIdx = neiBeginOffset + i * 8 + neighborOctGroupParticleIdx;
					uvec4 neiPositionData = particleData[positionsBufferOffset + neiParticleIdx];
					vec3 neiPosition = uintBitsToFloat(neiPositionData.xyz);

					uint neiCellID = neiPositionData.w;
					bool isValidNeighbor = neiParticleIdx < numParticles && neiExpectedCellID == neiCellID;

					NEAR_PAIR_RES_T res = processNearPair(centerParticleIdx, neiParticleIdx, position, neiPosition);
					if (isValidNeighbor && neiParticleIdx != centerParticleIdx)
						accumulatedValue += res;

#ifndef VNoSubgroups
					if (subgroupAny(!isValidNeighbor))
						break;
#endif
				}
			}
		}
	}

	accumulatedValue = clusteredAdd8(accumulatedValue);

	if (neighborOctGroupParticleIdx == 0 && cellID == cellID0)
	{
		processResult(accumulatedValue, centerParticleIdx);
	}
}
