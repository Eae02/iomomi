#ifndef DEFERRED_LIGHT_GLH
#define DEFERRED_LIGHT_GLH

#define RENDER_SETTINGS_BINDING 0
#include "GBData.glh"
#include "RenderSettings.glh"
#include <Deferred.glh>

layout(constant_id=100) const int numSamples = 1;

#ifdef VMSAA
layout(binding=1) uniform sampler2DMS gbColor1Sampler;
layout(binding=2) uniform sampler2DMS gbColor2Sampler;
layout(binding=3) uniform sampler2DMS gbDepthSampler;
#else
layout(binding=1) uniform sampler2D gbColor1Sampler;
layout(binding=2) uniform sampler2D gbColor2Sampler;
layout(binding=3) uniform sampler2D gbDepthSampler;
#endif

layout(location=0) out vec4 color_out;

vec2 texSize;

vec3 CalculateLighting(GBData data);

void main()
{
	color_out = vec4(0.0);
	
	ivec2 screenCoord = ivec2(gl_FragCoord.xy);
	
#ifdef VMSAA
	texSize = vec2(textureSize(gbColor1Sampler).xy);
#else
	texSize = vec2(textureSize(gbColor1Sampler, 0).xy);
#endif
	vec2 screenCoord01 = vec2(screenCoord) / texSize;
	
	for (int i = 0; i < numSamples; i++)
	{
		vec4 c1 = texelFetch(gbColor1Sampler, screenCoord, i);
		vec4 c2 = texelFetch(gbColor2Sampler, screenCoord, i);
		
		GBData data;
		data.hDepth = texelFetch(gbDepthSampler, screenCoord, i).r;
		data.worldPos = WorldPosFromDepth(data.hDepth, screenCoord01, renderSettings.invViewProjection);
		data.normal = SMDecode(c2.xy);
		data.albedo = c1.xyz;
		data.roughness = c2.z;
		data.metallic = c2.w;
		data.ao = c1.w;
		
		color_out.rgb += CalculateLighting(data);
	}
	color_out.rgb /= float(numSamples);
}

#endif
